<!DOCTYPE html>
<html>
<head>
    <title>Rowing Relay Calculator</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        .input-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; }
        input { padding: 5px; margin-right: 5px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { padding: 8px; border: 1px solid #ddd; text-align: left; }
        th { background-color: #f5f5f5; }
        .rower-inputs { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; }
        .results { background-color: #f9f9f9; padding: 15px; border-radius: 5px; margin-top: 20px; }
        .transition-row { background-color: #f5f5f5; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        function App() {
            // ... [Previous state and utility functions remain the same until calculateResults] ...

            const calculateResults = React.useCallback(() => {
                const numTransitions = state.numTurns - 1;
                const totalTransitionTime = numTransitions * state.transitionTime;
                const transitionSpeed = convertPaceToSpeed(state.transitionPaceMin, state.transitionPaceSec);
                const transitionDistance = totalTransitionTime * transitionSpeed;
                const activeDistance = state.totalDistance - transitionDistance;
                const distancePerTurn = activeDistance / state.numTurns;

                let currentTime = 0;
                let currentDistance = 0;
                let timelineEvents = [];
                let rowerIndex = 0;

                // Track last finish and next start times for each rower
                let rowerTimings = {
                    'Rower 1': { lastFinish: null, nextStart: null },
                    'Rower 2': { lastFinish: null, nextStart: null },
                    'Rower 3': { lastFinish: null, nextStart: null },
                    'Rower 4': { lastFinish: null, nextStart: null }
                };

                // First pass: Generate timeline and track finish/start times
                for (let turn = 0; turn < state.numTurns; turn++) {
                    const currentRower = state.rowers[rowerIndex];
                    const rowerSpeed = convertPaceToSpeed(currentRower.paceMin, currentRower.paceSec);
                    const timeForTurn = distancePerTurn / rowerSpeed;

                    // Update next start time for current rower
                    rowerTimings[currentRower.name].nextStart = currentTime;

                    timelineEvents.push({
                        type: 'row',
                        rower: currentRower.name,
                        startTime: currentTime,
                        duration: timeForTurn,
                        distance: distancePerTurn,
                        pace: rowerSpeed
                    });

                    currentTime += timeForTurn;
                    currentDistance += distancePerTurn;

                    // Update last finish time for current rower
                    rowerTimings[currentRower.name].lastFinish = currentTime;

                    if (turn < state.numTurns - 1) {
                        timelineEvents.push({
                            type: 'transition',
                            from: currentRower.name,
                            to: state.rowers[(rowerIndex + 1) % 4].name,
                            startTime: currentTime,
                            duration: state.transitionTime,
                            distance: state.transitionTime * transitionSpeed,
                            pace: transitionSpeed
                        });

                        currentTime += state.transitionTime;
                        currentDistance += state.transitionTime * transitionSpeed;
                    }

                    rowerIndex = (rowerIndex + 1) % 4;
                }

                // Calculate running averages and update timeline events
                timelineEvents = timelineEvents.map((event, index) => {
                    const eventsUpToNow = timelineEvents.slice(0, index + 1);
                    const totalDistance = eventsUpToNow.reduce((sum, e) => sum + e.distance, 0);
                    const totalTime = event.startTime + event.duration;
                    const averageSpeed = totalDistance / totalTime;
                    
                    return {
                        ...event,
                        cumulativeTime: totalTime,
                        cumulativeDistance: totalDistance,
                        averagePace: averageSpeed
                    };
                });

                setTimeline(timelineEvents);

                // Calculate rest periods between each rower's turns
                const rowerResults = state.rowers.map(rower => {
                    const rowerEvents = timelineEvents.filter(e => 
                        e.type === 'row' && e.rower === rower.name
                    );
                    
                    const totalActiveTime = rowerEvents.reduce((sum, e) => sum + e.duration, 0);
                    const numTurnsForRower = rowerEvents.length;

                    // Calculate rest times between turns
                    let restTimes = [];
                    for (let i = 0; i < rowerEvents.length - 1; i++) {
                        const currentTurnEnd = rowerEvents[i].startTime + rowerEvents[i].duration;
                        const nextTurnStart = rowerEvents[i + 1].startTime;
                        restTimes.push(nextTurnStart - currentTurnEnd);
                    }

                    const avgRestTime = restTimes.length > 0 
                        ? restTimes.reduce((a, b) => a + b, 0) / restTimes.length 
                        : 0;

                    return {
                        name: rower.name,
                        timePerTurn: totalActiveTime / numTurnsForRower,
                        totalActiveTime,
                        restTimeBetweenTurns: avgRestTime,
                        individualRestTimes: restTimes
                    };
                });

                setResults({
                    totalTime: currentTime,
                    activeDistance,
                    transitionDistance,
                    distancePerTurn,
                    rowerResults
                });
            }, [state]);

            // ... [Rest of the component code remains the same] ...

            return (
                <div className="container">
                    {/* ... [Previous JSX remains the same until results section] ... */}

                    {results && (
                        <div className="results">
                            <h2>Results</h2>
                            <p>Total Time: {formatTime(results.totalTime)}</p>
                            <p>Distance per Turn: {Math.round(results.distancePerTurn)}m</p>
                            <p>Active Distance: {Math.round(results.activeDistance)}m</p>
                            <p>Transition Distance: {Math.round(results.transitionDistance)}m</p>

                            <h3>Individual Results</h3>
                            {results.rowerResults.map(rower => (
                                <div key={rower.name}>
                                    <h4>{rower.name}</h4>
                                    <p>Time per Turn: {formatTime(rower.timePerTurn)}</p>
                                    <p>Average Rest Between Turns: {formatTime(rower.restTimeBetweenTurns)}</p>
                                    <details>
                                        <summary>Individual Rest Times</summary>
                                        <ul>
                                            {rower.individualRestTimes.map((time, index) => (
                                                <li key={index}>Rest {index + 1}: {formatTime(time)}</li>
                                            ))}
                                        </ul>
                                    </details>
                                </div>
                            ))}

                            {/* ... [Timeline table remains the same] ... */}
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>